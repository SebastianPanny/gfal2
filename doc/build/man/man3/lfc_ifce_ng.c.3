.TH "/home/adevress/myworkspace/gfal/src/common/lfc/lfc_ifce_ng.c" 3 "3 Oct 2011" "Version 2.0.1" "CERN org.glite.Gfal" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/adevress/myworkspace/gfal/src/common/lfc/lfc_ifce_ng.c \- main internal file of the lfc plugin module 
.SH SYNOPSIS
.br
.PP
\fC#include <errno.h>\fP
.br
\fC#include <stdio.h>\fP
.br
\fC#include <string.h>\fP
.br
\fC#include <time.h>\fP
.br
\fC#include <sys/types.h>\fP
.br
\fC#include <dlfcn.h>\fP
.br
\fC#include <stdlib.h>\fP
.br
\fC#include <pthread.h>\fP
.br
\fC#include <serrno.h>\fP
.br
\fC#include '../gfal_constants.h'\fP
.br
\fC#include '../gfal_types.h'\fP
.br
\fC#include '../mds/gfal_common_mds.h'\fP
.br
\fC#include '../gfal_common_interface.h'\fP
.br
\fC#include 'lfc_ifce_ng.h'\fP
.br
\fC#include '../gfal_common_errverbose.h'\fP
.br

.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fB_GNU_SOURCE\fP"
.br
.ti -1c
.RI "#define \fBGFAL_LFN_MAX_LEN\fP   2048"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBgfal_lfc_regex_compile\fP (regex_t *rex, GError **err)"
.br
.ti -1c
.RI "void \fBgfal_lfc_init_thread\fP (struct lfc_ops *ops)"
.br
.ti -1c
.RI "int \fBgfal_lfc_startSession\fP (struct lfc_ops *ops, GError **err)"
.br
.ti -1c
.RI "void \fBgfal_auto_maintain_session\fP (struct lfc_ops *ops, GError **err)"
.br
.ti -1c
.RI "void \fBlfc_set_session_timeout\fP (int timeout)"
.br
.ti -1c
.RI "char * \fBgfal_get_lfchost_envar\fP (GError **err)"
.br
.ti -1c
.RI "char * \fBgfal_convert_guid_to_lfn\fP (plugin_handle handle, char *guid, GError **err)"
.br
.ti -1c
.RI "int \fBgfal_convert_guid_to_lfn_r\fP (plugin_handle handle, const char *guid, char *buff_lfn, size_t sbuff_lfn, GError **err)"
.br
.ti -1c
.RI "char * \fBgfal_setup_lfchost\fP (gfal_handle handle, GError **err)"
.br
.ti -1c
.RI "lfc_ops * \fBgfal_load_lfc\fP (const char *name, GError **err)"
.br
.ti -1c
.RI "int \fBgfal_lfc_convert_statg\fP (struct stat *output, struct lfc_filestatg *input, GError **err)"
.br
.ti -1c
.RI "int \fBgfal_lfc_convert_lstat\fP (struct stat *output, struct lfc_filestat *input, GError **err)"
.br
.ti -1c
.RI "int \fBgfal_lfc_mkdir_rec\fP (struct lfc_ops *ops, char *browser_path, const char *full_path, mode_t mode, GError **err)"
.br
.ti -1c
.RI "int \fBgfal_lfc_ifce_mkdirpG\fP (struct lfc_ops *ops, const char *path, mode_t mode, gboolean pflag, GError **err)"
.br
.ti -1c
.RI "char ** \fBgfal_lfc_getSURL\fP (struct lfc_ops *ops, const char *path, GError **err)"
.br
.ti -1c
.RI "int \fBgfal_lfc_getComment\fP (struct lfc_ops *ops, const char *lfn, char *buff, size_t s_buff, GError **err)"
.br
.ti -1c
.RI "int \fBgfal_lfc_setComment\fP (struct lfc_ops *ops, const char *lfn, const char *buff, size_t s_buff, GError **err)"
.br
.ti -1c
.RI "int \fBgfal_lfc_getChecksum\fP (struct lfc_ops *ops, const char *lfn, lfc_checksum *checksum, GError **err)"
.br
.ti -1c
.RI "int \fBgfal_lfc_statg\fP (struct lfc_ops *ops, const char *lfn, struct lfc_filestatg *statbuf, GError **err)"
.br
.ti -1c
.RI "ssize_t \fBg_strv_catbuff\fP (char **strv, char *buff, size_t size)"
.br
.ti -1c
.RI "int \fBgfal_lfc_get_errno\fP (struct lfc_ops *ops)"
.br
.ti -1c
.RI "char * \fBgfal_lfc_get_strerror\fP (struct lfc_ops *ops)"
.br
.ti -1c
.RI "void \fBgfal_generate_guidG\fP (char *buf, GError **err)"
.br
.RI "\fIgenerate an uiid string Generate a uuid string and cpy it in the buf, \fP"
.in -1c
.SH "Detailed Description"
.PP 
main internal file of the lfc plugin module 

\fBAuthor:\fP
.RS 4
Adrien Devresse 
.RE
.PP
\fBVersion:\fP
.RS 4
0.0.1 
.RE
.PP
\fBDate:\fP
.RS 4
02/05/2011 
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "char* gfal_convert_guid_to_lfn (plugin_handle handle, char * guid, GError ** err)"
.PP
convert a guid to a lfn link with a call to the lfclib 
.PP
\fBParameters:\fP
.RS 4
\fIhandle\fP handle of the lfc plugin 
.br
\fIstring\fP of the guid 
.br
\fIerr\fP : Error report system 
.RE
.PP
\fBReturns:\fP
.RS 4
: string of the lfn if success or NULL char* if error 
.RE
.PP

.SS "int gfal_convert_guid_to_lfn_r (plugin_handle handle, const char * guid, char * buff_lfn, size_t sbuff_lfn, GError ** err)"
.PP
convert a guid to a lfn link with a call to the lfclib in a reantrant( buffer mode ) 
.PP
\fBParameters:\fP
.RS 4
\fIhandle\fP plugin handle 
.br
\fIguid\fP string of the guid 
.br
\fIbuff_lfn\fP buffer for the lfn result 
.br
\fIsbuff_lfn\fP size of the buffer 
.br
\fIerr\fP : Error report system 
.RE
.PP
\fBReturns:\fP
.RS 4
: 0 else -1 if error and err is set 
.RE
.PP

.SS "void gfal_generate_guidG (char * buf, GError ** err)"
.PP
generate an uiid string Generate a uuid string and cpy it in the buf, 
.PP
\fBWarning:\fP
.RS 4
buff must be > uuid size ( 37 bytes ) 
.RE
.PP

.SS "char** gfal_lfc_getSURL (struct lfc_ops * ops, const char * path, GError ** err)"
.PP
return a list of surls from a getreplica request 
.SS "int gfal_lfc_ifce_mkdirpG (struct lfc_ops * ops, const char * path, mode_t mode, gboolean pflag, GError ** err)"
.PP
Implementation of mkdir -p call on the lfc 
.SS "void gfal_lfc_init_thread (struct lfc_ops * ops)"
.PP
Routine for internal lfc hack, need to be call for the thread safety 
.SS "int gfal_lfc_mkdir_rec (struct lfc_ops * ops, char * browser_path, const char * full_path, mode_t mode, GError ** err)"
.PP
Begin a recursive call on mkdir to create a full tree path 
.PP
\fBWarning:\fP
.RS 4
not safe, please ensure that string begin by '/' 
.RE
.PP

.SS "struct lfc_ops* gfal_load_lfc (const char * name, GError ** err)"
.PP
load the shared library and link the symbol for the LFC usage 
.PP
\fBParameters:\fP
.RS 4
\fIname\fP : name of the library 
.br
\fIerr,:\fP error report 
.RE
.PP

.SS "char* gfal_setup_lfchost (gfal_handle handle, GError ** err)"
.PP
setup the lfc_host correctly for the lfc calls 
.PP
\fBParameters:\fP
.RS 4
\fIerr\fP GError report system if 
.RE
.PP
\fBReturns:\fP
.RS 4
string of the endpoint, need to be free or NULL if error 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for CERN org.glite.Gfal from the source code.
