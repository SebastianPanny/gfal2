.TH "/home/adevress/myworkspace/gfal/src/common/gfal_common_catalog.c" 3 "8 Jul 2011" "Version 1.90" "CERN org.glite.Gfal" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/adevress/myworkspace/gfal/src/common/gfal_common_catalog.c \- the file of the common lib for the catalog management 
.SH SYNOPSIS
.br
.PP
\fC#include <stdio.h>\fP
.br
\fC#include <stdlib.h>\fP
.br
\fC#include <string.h>\fP
.br
\fC#include <dlfcn.h>\fP
.br
\fC#include <unistd.h>\fP
.br
\fC#include <sys/types.h>\fP
.br
\fC#include <fcntl.h>\fP
.br
\fC#include 'gfal_types.h'\fP
.br
\fC#include 'gfal_common_catalog.h'\fP
.br
\fC#include 'gfal_constants.h'\fP
.br
\fC#include 'gfal_common_errverbose.h'\fP
.br
\fC#include 'gfal_common_filedescriptor.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "char ** \fBgfal_catalogs_get_list\fP (gfal_handle handle, GError **err)"
.br
.ti -1c
.RI "int \fBgfal_catalogs_instance\fP (gfal_handle handle, GError **err)"
.br
.ti -1c
.RI "int \fBgfal_catalogs_operation_executor\fP (gfal_handle handle, gboolean(*checker)(gfal_catalog_interface *, GError **), int(*executor)(gfal_catalog_interface *, GError **), GError **err)"
.br
.ti -1c
.RI "int \fBgfal_catalogs_accessG\fP (gfal_handle handle, const char *path, int mode, GError **err)"
.br
.ti -1c
.RI "int \fBgfal_catalog_statG\fP (gfal_handle handle, const char *path, struct stat *st, GError **err)"
.br
.ti -1c
.RI "int \fBgfal_catalog_lstatG\fP (gfal_handle handle, const char *path, struct stat *st, GError **err)"
.br
.ti -1c
.RI "int \fBgfal_catalogs_delete\fP (gfal_handle handle, GError **err)"
.br
.ti -1c
.RI "int \fBgfal_catalog_chmodG\fP (gfal_handle handle, const char *path, mode_t mode, GError **err)"
.br
.ti -1c
.RI "int \fBgfal_catalog_renameG\fP (gfal_handle handle, const char *oldpath, const char *newpath, GError **err)"
.br
.ti -1c
.RI "int \fBgfal_catalog_mkdirp\fP (gfal_handle handle, const char *path, mode_t mode, gboolean pflag, GError **err)"
.br
.ti -1c
.RI "int \fBgfal_catalog_rmdirG\fP (gfal_handle handle, const char *path, GError **err)"
.br
.ti -1c
.RI "gfal_file_handle \fBgfal_catalog_opendirG\fP (gfal_handle handle, const char *name, GError **err)"
.br
.ti -1c
.RI "int \fBgfal_catalog_closedirG\fP (gfal_handle handle, gfal_file_handle fh, GError **err)"
.br
.ti -1c
.RI "gfal_file_handle \fBgfal_catalog_openG\fP (gfal_handle handle, const char *path, int flag, mode_t mode, GError **err)"
.br
.ti -1c
.RI "int \fBgfal_catalog_closeG\fP (gfal_handle handle, gfal_file_handle fh, GError **err)"
.br
.ti -1c
.RI "dirent * \fBgfal_catalog_readdirG\fP (gfal_handle handle, gfal_file_handle fh, GError **err)"
.br
.ti -1c
.RI "char ** \fBgfal_catalog_getSURL\fP (gfal_handle handle, const char *path, GError **err)"
.br
.ti -1c
.RI "int \fBgfal_catalog_getTURLG\fP (gfal_handle handle, const char *surl, char *buff_turl, int size_turl, char **reqtoken, GError **err)"
.br
.ti -1c
.RI "int \fBgfal_catalog_putTURLG\fP (gfal_handle handle, const char *surl, char *turl_buff, int size_turl, char **reqtoken, GError **err)"
.br
.ti -1c
.RI "int \fBgfal_catalog_readG\fP (gfal_handle handle, gfal_file_handle fh, void *buff, size_t s_buff, GError **err)"
.br
.ti -1c
.RI "int \fBgfal_catalog_writeG\fP (gfal_handle handle, gfal_file_handle fh, void *buff, size_t s_buff, GError **err)"
.br
.ti -1c
.RI "char * \fBgfal_catalog_resolve_guid\fP (gfal_handle handle, const char *guid, GError **err)"
.br
.ti -1c
.RI "char * \fBgfal_get_cat_type\fP (GError **err)"
.br
.RI "\fIcatalog type getter \fP"
.ti -1c
.RI "void \fBgfal_catalog_open_resolve_guid\fP (gfal_handle handle, const char *path, char *buff, size_t s_buff, GError **err)"
.br
.ti -1c
.RI "gfal_file_handle \fBgfal_catalog_open_globalG\fP (gfal_handle handle, const char *path, int flag, mode_t mode, GError **err)"
.br
.in -1c
.SH "Detailed Description"
.PP 
the file of the common lib for the catalog management 

\fBAuthor:\fP
.RS 4
Devresse Adrien 
.RE
.PP
\fBVersion:\fP
.RS 4
0.0.1 
.RE
.PP
\fBDate:\fP
.RS 4
8/04/2011 
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "int gfal_catalog_chmodG (gfal_handle handle, const char * path, mode_t mode, GError ** err)"
.PP
Execute the chmod function on the first compatible catalog ( checked with check_url func ) 
.PP
\fBReturns:\fP
.RS 4
0 if success or -1 and set the GError to the correct errno value with a description msg 
.RE
.PP

.SS "int gfal_catalog_closedirG (gfal_handle handle, gfal_file_handle fh, GError ** err)"
.PP
close the given dir handle in the proper catalog 
.SS "int gfal_catalog_closeG (gfal_handle handle, gfal_file_handle fh, GError ** err)"
.PP
close the given file handle in the proper catalog 
.SS "char** gfal_catalog_getSURL (gfal_handle handle, const char * path, GError ** err)"
.PP
Resolve a link on the catalog to a list of surl 
.PP
\fBReturns:\fP
.RS 4
pointer to a table of string with all the surls, table end with NULL, or return NULL if error 
.RE
.PP
\fBWarning:\fP
.RS 4
must be free with g_list_free_full 
.RE
.PP

.SS "int gfal_catalog_getTURLG (gfal_handle handle, const char * surl, char * buff_turl, int size_turl, char ** reqtoken, GError ** err)"
.PP
Resolve a surl to a 'GET' turl 
.PP
\fBReturns:\fP
.RS 4
pointer to a table of string with all the surls, table end with NULL, or return NULL if error 
.RE
.PP

.SS "int gfal_catalog_lstatG (gfal_handle handle, const char * path, struct stat * st, GError ** err)"
.PP
Execute a lstat function in the lfc 
.SS "int gfal_catalog_mkdirp (gfal_handle handle, const char * path, mode_t mode, gboolean pflag, GError ** err)"
.PP
Execute a mkdir function on the first compatible catalog ( checked with check url func ) 
.PP
\fBParameters:\fP
.RS 4
\fIhandle\fP handle of the current context 
.br
\fIpath\fP path to create 
.br
\fImode\fP right of the file created 
.br
\fIpflag\fP if TRUE, execute the request recursively if necessary else work as the common mkdir system call 
.br
\fIGError\fP error report system 
.RE
.PP
\fBWarning:\fP
.RS 4
no check on the path, please check the path before 
.RE
.PP
\fBReturns:\fP
.RS 4
return 0 if success else return -1 
.RE
.PP

.SS "gfal_file_handle gfal_catalog_open_globalG (gfal_handle handle, const char * path, int flag, mode_t mode, GError ** err)"
.PP
Complete openG func with catalog->surl resolution This func try to resolve the path to a valid surl and open surl with the srm module else open is call on the first compatible catalog like in the normal way. 
.PP
\fBReturns:\fP
.RS 4
pointer to file handle if success else NULL if error 
.RE
.PP

.SS "void gfal_catalog_open_resolve_guid (gfal_handle handle, const char * path, char * buff, size_t s_buff, GError ** err)"
.PP
if url is guid, resolve it and put the result in buffer, else put the url in the buffer 
.SS "gfal_file_handle gfal_catalog_opendirG (gfal_handle handle, const char * name, GError ** err)"
.PP
Execute a opendir function on the first compatible catalog ( checked with check url func ) 
.PP
\fBParameters:\fP
.RS 4
\fIhandle\fP handle of the current context 
.br
\fIpath\fP path to open 
.br
\fIGError\fP error report system 
.RE
.PP
\fBReturns:\fP
.RS 4
gfal_file_handle pointer given to the handle or NULL if error 
.RE
.PP

.SS "gfal_file_handle gfal_catalog_openG (gfal_handle handle, const char * path, int flag, mode_t mode, GError ** err)"
.PP
open the file specified by path on the proper catalog with the specified flag and mode 
.SS "int gfal_catalog_putTURLG (gfal_handle handle, const char * surl, char * turl_buff, int size_turl, char ** reqtoken, GError ** err)"
.PP
Resolve a surl to a 'PUT' turl  if success else -1 if error, 
.SS "struct dirent* gfal_catalog_readdirG (gfal_handle handle, gfal_file_handle fh, GError ** err)"
.PP
execute a readdir for the given file handle on the appropriate catalog 
.SS "int gfal_catalog_readG (gfal_handle handle, gfal_file_handle fh, void * buff, size_t s_buff, GError ** err)"
.PP
do a read operation on the catalog, read s_buff chars on the fd device 
.PP
\fBReturns:\fP
.RS 4
return number of bytes readed else -1 if errors and GError is set 
.RE
.PP

.SS "int gfal_catalog_renameG (gfal_handle handle, const char * oldpath, const char * newpath, GError ** err)"
.PP
Execute the rename function on the first compatible catalog ( checked with check_url func ) 
.PP
\fBReturns:\fP
.RS 4
0 if success or -1 and set the GError to the correct errno value with a description msg 
.RE
.PP

.SS "int gfal_catalog_rmdirG (gfal_handle handle, const char * path, GError ** err)"
.PP
Execute a rmdir function on the first compatible catalog ( checked with check url func ) 
.PP
\fBParameters:\fP
.RS 4
\fIhandle\fP handle of the current context 
.br
\fIpath\fP path to delete 
.br
\fIGError\fP error report system 
.RE
.PP
\fBWarning:\fP
.RS 4
no check on the path, please check the path before 
.RE
.PP
\fBReturns:\fP
.RS 4
return 0 if success else return -1 
.RE
.PP

.SS "int gfal_catalog_statG (gfal_handle handle, const char * path, struct stat * st, GError ** err)"
.PP
Execute a stat function on the lfc catalog 
.SS "int gfal_catalog_writeG (gfal_handle handle, gfal_file_handle fh, void * buff, size_t s_buff, GError ** err)"
.PP
do a write operation on the catalog, write s_buff chars on the fd device 
.PP
\fBReturns:\fP
.RS 4
return number of bytes readed else -1 if errors and GError is set 
.RE
.PP

.SS "int gfal_catalogs_accessG (gfal_handle handle, const char * path, int mode, GError ** err)"
.PP
Execute an access function on the first catalog compatible in the catalog list return the result of the first valid catalog for a given URL 
.PP
\fBReturns:\fP
.RS 4
result of the access method or -1 if error and set GError with the correct value error : EPROTONOSUPPORT means that the URL is not matched by a catalog 
.RE
.PP

.SS "int gfal_catalogs_delete (gfal_handle handle, GError ** err)"
.PP
Delete all instance of catalogs 
.SS "int gfal_catalogs_instance (gfal_handle handle, GError ** err)"
.PP
Instance all catalogs for use if it's not the case return the number of catalog available 
.SS "char* gfal_get_cat_type (GError **)"
.PP
catalog type getter 
.PP
\fBReturns:\fP
.RS 4
return a string of the type of the catalog return NULL if an error occured and set the GError correctly 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for CERN org.glite.Gfal from the source code.
